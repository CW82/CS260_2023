Create some tests (at least one per function) that you want your Binary Search Tree (BST) to pass before you start coding.

Implement a binary search tree that includes:
- Nodes to store values
- An add function that adds a new value in the appropriate location based on our ordering rules,
(I likely used less than or equal to going to the left and greater than values going to the right)
- A remove function that finds and removes a value and then picks an appropriate replacement node
(successor is a term often used for this)
- We have at least one tree traversal function (I recommend starting with an in-order traversal!)
Bonus if you implement the three common traversals (pre-order, post-order, in-order)
More Bonus if you also include a breadth-first traversal (sometimes called a level-order search)
- Analyze and compare the complexity of insert and search as compared to a binary tree without any order in its nodes.

add():
- check, that's listed below, if the root is the root is NULL
 if it is, set the value that's to be inserted as the root
 else, do the following:
- Check the value that you want inserted against the currentNode's value
 if it's less than currentNode's value, put it on the left side of the root node
 else, put it on the right side of the root node 

remove():
- check if the root is null, if it is, return the root
- if the data is less than the root, set the root's left to be travered for a node to be removed. Do the same if it's the right side
- check if the root & l & r nullptr, if true, then return null
- if it only has a left child, return left. Do the same with the right

Tests:
adding():
- top of tree
- bottom of tree
- middle of tree
- duplicate?
- make sure it inerts the value at the right location in the tree
- check if it's inserting at

removing():
- make sure it removes the right value
- top of tree
- bottom of tree
- middle of tree
- a value that's not there?

Note:
I used the same numbers/values that you used for your example in class 

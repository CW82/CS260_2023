(20%) Create a design before you start coding that describes or shows how a graph structure could be used to store some kinds of data and attempt to solve some kind of problem (yes, this can be a game that needs a graph to represent a map!),

(20%) Create some tests (at least two for each piece of functionality) before you start coding...

(40%) Implement a graph class with at least (this category effectively combines implementation and specification, partly to emphasize getting the algorithms working!):

(5%) a function to add a new vertex to the graph (perhaps add_vertex(vertex_name)),

(5%) a function to add a new edge between two vertices of the graph (perhaps add_edge(source, destination) or source.add_edge(destination)),

(15%) a function for a shortest path algorithm (perhaps shortest_path(source, destination)),

(15%) a function for a minimum spanning tree algorithm (example min_span_tree()).

(10%) Analyze the complexity of all of your graph behaviors (effectively a part of our documentation for grading purposes),

(10%) Once you have implemented and tested your code, add to the README file what line(s) of code or inputs and outputs show your work meeting each of the above requirements (or better, include a small screen snip of where it meets the requirement!).

